---
title: "Deploying to TheoR.net"
description: "Guide to deploying new websites and services on the theor.net infrastructure."
created: 2026-02-09
ntpp:
  - about
---

import Footnote from '@components/Footnote.astro';

## Overview

TheoR.net runs on a single Hetzner VPS (`cx33`, Nuremberg) with NixOS. Apps are Docker containers managed declaratively through YAML configs and served behind nginx with automatic ACME/Let's Encrypt TLS. DNS lives in Porkbun, managed via Terraform.

There are two deployment paths:

- **Registry** — image is pushed to GHCR by CI; the server pulls it automatically via watchtower.
- **Local** — image is built on your machine and pushed over SSH. No CI required.

The infra repo is at [theor.net-infra](https://github.com/theoryzhenkov/theor.net-infra)<Footnote id="infra-repo">If the link is stale, check the [About](/about) page.</Footnote>.

---

## Registry App (GHCR)

This is the standard path for apps with a GitHub repo. Push to `main` triggers CI, which builds the Docker image and pushes it to `ghcr.io`. Watchtower on the server detects the new image and restarts the container.

### 1. Dockerfile

Your repo needs a `Dockerfile` at the root. A typical static site:

```dockerfile
FROM oven/bun:1-alpine AS builder
WORKDIR /app
COPY package.json bun.lock ./
RUN bun install --frozen-lockfile
COPY . .
RUN bun run build

FROM nginx:alpine AS production
COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

The container must listen on a single port (here `80`).

### 2. GitHub Actions workflow

Create `.github/workflows/deploy.yml`:

```yaml
name: Build and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-push:
    uses: theoryzhenkov/.github/.github/workflows/deploy-docker.yml@main
    with:
      app_name: my-app-name
    permissions:
      contents: read
      packages: write
```

The shared workflow builds the image and pushes it to `ghcr.io/theoryzhenkov/<repo>/<app_name>:latest`.

### 3. App config

In the infra repo, create `nixos/apps/<app-name>.yaml`:

```yaml
image: ghcr.io/theoryzhenkov/<repo>/<app-name>:latest
containerPort: 80
hostPort: <unique-port>
domain: <subdomain>.theor.net
```

- `containerPort` — the port your Docker container exposes internally.
- `hostPort` — a unique port on the host for nginx to proxy to. Pick something in `8100–8199` that isn't taken; check existing configs or run `just app list` in the `nixos/` directory.
- `domain` — the full domain. For subdomains under `leaves.theor.net`, use `<name>.leaves.theor.net`.

### 4. DNS record

In `terraform/main.tf`, add a Porkbun DNS A record pointing the subdomain to the server:

```hcl
resource "porkbun_dns_record" "theor_net_<name>" {
  domain   = "theor.net"
  name     = "<subdomain>"
  type     = "A"
  content  = hcloud_primary_ip.web_ipv4.ip_address
  ttl      = 600
  priority = 0
}
```

For wildcard subdomains (e.g. `*.leaves`), that record already exists. You only need a new record for a new top-level subdomain like `foo.theor.net`.

Apply with:

```bash
cd terraform && just apply
```

### 5. Generate and deploy

```bash
cd nixos
just app generate   # regenerates apps/apps.lock.nix from YAML files
just deploy         # nixos-rebuild on the server
```

After the first deploy, watchtower handles subsequent image updates automatically. You can force a restart with:

```bash
ssh hetzner-theor.net-web-1 'systemctl restart <app-name>'
```

---

## Local App

For apps without a GitHub repo or CI pipeline. You build locally and push over SSH.

### 1. Create app config

```bash
cd nixos
just app create my-app   # generates apps/my-app.yaml with defaults
```

Edit the generated YAML — the image will default to `local/my-app:latest`.

### 2. Build the image

```bash
docker build -t local/my-app:latest /path/to/app
```

### 3. Deploy

```bash
cd nixos
just app generate          # update Nix config
just app deploy my-app     # push image to server via SSH + docker save/load
just deploy                # apply NixOS config (needed for first deploy)
```

For subsequent updates, rebuild the image and run `just app deploy my-app` — the script restarts the systemd service on the server.

---

## How It Works

For reference, here's what happens under the hood.

### App YAML >> NixOS

`just app generate` runs `scripts/app.sh generate`, which reads every `nixos/apps/*.yaml` and produces `apps/apps.lock.nix` — a Nix attrset consumed by `modules/apps.nix`. That module:

1. Creates a **systemd service** per app that runs `docker run` with the port mapping.
2. Creates an **nginx virtual host** per app with `forceSSL`, `enableACME`, and a reverse proxy to `127.0.0.1:<hostPort>`.

GHCR auth is handled via sops-nix secrets injected into `/root/.docker/config.json` on activation.

### DNS >> Terraform

Porkbun DNS is managed in `terraform/main.tf` using the `porkbun` provider. Credentials are encrypted with sops. Each subdomain gets an A record pointing to the Hetzner server's static IPv4.
